/*
 * readKey.c
 *
 *  Created on: 25 дек. 2022 г.
 *      Author: Maksim Ilyin (imax9.narod.ru)
 */
#include "main.h"
#include "fileBrowser.h"
#include "pins.h"
#include "spi.h"

#define TIME_MS_FIRST_PRESS 800
#define TIME_MS_OTHER_PRESS 150

/**
   returns an event generated by the keyboard.
   if nothing is pressed, no event (0) is return;
   is something (recognizable by the core) is pressed, EVENT_KEY_PRESS is returned and key/cmd arguments are updated

*/
int readKeyboard(unsigned char *key, unsigned char *cmd) {
  unsigned char keyboard_data;
  int event = 0;
  static int last_keyboard_data = 255;
  static int state = 0;
  static uint32_t timing;
  /*
     states:
     0 => nothing pressed, waiting
     1 => something pressed for less than 1sec (should generate onKeyPress event only once)
     2 => something pressed for more than 1sec (should generate onKeyPress event once per 0.2sec)
  */

//  SPI.setModule( SPI_FPGA );
  SPI_DESELECTED(); // ensure SS stays high for now
  SPI_SELECTED();

//  keyboard_data = SPI.transfer(0x10); //command to read from ps2 keyboad
  uint8_t data=0x10;
  HAL_SPI_TransmitReceive(&spiFPGA,&data,&keyboard_data,1,100);

  //keyboard_data = SPI.transfer(0);    //dummy data, just to read the response
  data=0x00;
  HAL_SPI_TransmitReceive(&spiFPGA,&data,&keyboard_data,1,100);

  *cmd = (keyboard_data & 0xe0) >> 5;  //just the 3 msb are the command
  *key = (keyboard_data & 0x1f);       //just the lower 5 bits are keys

  if ( state == 0 && keyboard_data != 255 ) { // 255 = nothing is pressed
    // generate event onkeypress, update state, update timing
    state = 1;
    timing = HAL_GetTick();
    event = EVENT_KEYPRESS;
  } else if ( state == 1 && last_keyboard_data == keyboard_data ) {
    // if user keeps pressing the same key, wait until 1 sec, then generate event keypress and go to state 2
    if ( ( HAL_GetTick() - timing) >= TIME_MS_FIRST_PRESS ) {
      state = 2;
      timing = HAL_GetTick();
      event = EVENT_KEYPRESS;
    }
  } else if ( state == 1 && keyboard_data == 255 ) {
    // TODO: could generate a keyUp event if we needed one
    // if user released the key, returns to state 0
    state = 0;
  } else if ( state == 1 && keyboard_data != last_keyboard_data ) {
    // if user with high dexterity managed to change the key without going through state 0, generate new onkeypress, and update timing
    timing = HAL_GetTick();
    event = EVENT_KEYPRESS;
  } else if ( state == 2 && last_keyboard_data == keyboard_data  ) {
    // user is still pressing it
    if ( (HAL_GetTick() - timing) >= TIME_MS_OTHER_PRESS ) {
      timing = HAL_GetTick();
      event = EVENT_KEYPRESS;
    }
  } else if ( state == 2 && keyboard_data == 255  ) {
    // user finally released it
    state = 0;
  } else if ( state == 2 && keyboard_data != last_keyboard_data ) {
    // if user with high dexterity managed to change the key without going through state 0, generate new onkeypress, and update timing
    state = 1;
    timing = HAL_GetTick();
    event = EVENT_KEYPRESS;
  }

  last_keyboard_data = keyboard_data;

  SPI_DESELECTED(); // SS high
//  SPI.setModule( SPI_SD );

  if ( event == EVENT_KEYPRESS ) {
    dbgprintf("OnKeyPress: %X - cmd: %X - key: %X\n", keyboard_data, *cmd, *key);
  }
  return event;
}

/**
   wait until a key (mapped on the core) is pressed
*/
void waitKeyPress() {
  unsigned char key, cmd;

  while ( readKeyboard(&key, &cmd) != EVENT_KEYPRESS ) {
    HAL_Delay(100);
  }
}

